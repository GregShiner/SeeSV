use crate::ast;

grammar;

Int: i32 = INT => <>.parse().unwrap();
Float: f32 = FLOAT => <>.parse().unwrap();
String: String = {
    <s:DOUBLE_STRING> => s[1..s.len()-1].to_owned(),
    <s:SINGLE_STRING> => s[1..s.len()-1].to_owned()
};
Identifier: String = <s:ID> => s.to_owned();

match {
    r"-?\d+" => INT
} else {
    r"-?\d*.\d+" => FLOAT,
} else {
    r#""(?:\\(?:["\\/bfnrt]|u[a-fA-F0-9]{4})|[^"\\\x00-\x1F\x7F]+)*""# => DOUBLE_STRING,
    r#"'(?:\\(?:['\\/bfnrt]|u[a-fA-F0-9]{4})|[^'\\\x00-\x1F\x7F]+)*'"# => SINGLE_STRING,
} else {
    r"(?i)SELECT\s+" => SELECT,
    r"(?i)\s+FROM\s+" => FROM,
} else {
    r"[a-zA-Z_][a-zA-Z0-9_]*" => ID,
    _
}

pub Immediate: ast::Immediate = {
    Int => ast::Immediate::Int(<>),
    Float => ast::Immediate::Float(<>),
    String => ast::Immediate::String(<>),
};

pub SelectExpr: ast::SelectExpr = {
    "*" => ast::SelectExpr::All,
    Immediate => ast::SelectExpr::Immediate(<>)
};

pub SelectExprs = Comma<SelectExpr>;

// Comma seperated list of T
Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

pub TableRef: ast::TableRef = {
    String => ast::TableRef::String(<>),
    Identifier => ast::TableRef::Identifier(<>)
}

pub SelectQuery: ast::SelectQuery = {
    SELECT <select_exprs:SelectExprs> FROM <table_ref:TableRef> r"\s*;" => ast::SelectQuery {<>}
};

pub Query: ast::Query = {
    SelectQuery => ast::Query::Select(<>)
};
